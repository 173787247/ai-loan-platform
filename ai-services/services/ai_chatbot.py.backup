import asyncio
import json
import logging
import numpy as np
from typing import List, Dict, Any, Optional
from datetime import datetime
from enum import Enum
import uuid

logger = logging.getLogger(__name__)

class ChatbotRole(Enum):
    """èŠå¤©æœºå™¨äººè§’è‰²æšä¸¾"""
    GENERAL = "general"
    LOAN_SPECIALIST = "loan_specialist"
    RISK_ANALYST = "risk_analyst"
    TECHNICAL_SUPPORT = "technical_support"

class AIChatbot:
    """AIèŠå¤©æœºå™¨äºº - åŸºäºRAG+LLMåŠ¨æ€ç”Ÿæˆé“¶è¡Œå¯¹æ¯”"""
    
    def __init__(self, vector_rag_service=None, llm_service=None):
        self.vector_rag_service = vector_rag_service
        self.llm_service = llm_service
        self.rag_kb = vector_rag_service  # æ·»åŠ rag_kbå±æ€§
        self.role = ChatbotRole.GENERAL
        self.sessions = {}  # å­˜å‚¨ä¼šè¯ä¿¡æ¯
    
    def set_role(self, role: ChatbotRole):
        """è®¾ç½®èŠå¤©æœºå™¨äººè§’è‰²"""
        self.role = role
    
    def create_session(self, user_id: str, role: ChatbotRole = None) -> str:
        """åˆ›å»ºèŠå¤©ä¼šè¯"""
        session_id = str(uuid.uuid4())
        
        self.sessions[session_id] = {
            'user_id': user_id,
            'role': role or self.role,
            'created_at': datetime.now(),
            'messages': []
        }
        
        return session_id
    
    async def process_message(self, session_id: str, message: str, user_info: dict = None) -> dict:
        """å¤„ç†èŠå¤©æ¶ˆæ¯"""
        if session_id not in self.sessions:
            raise ValueError(f"ä¼šè¯ä¸å­˜åœ¨: {session_id}")
        
        session = self.sessions[session_id]
        session['messages'].append({
            'role': 'user',
            'content': message,
            'timestamp': datetime.now()
        })
        
        # ç”Ÿæˆå›å¤
        messages = [{'role': 'user', 'content': message}]
        context = {
            'user_info': user_info,
            'session_id': session_id
        }
        
        response = await self.generate_response(messages, context)
        
        # ä¿å­˜AIå›å¤
        session['messages'].append({
            'role': 'assistant',
            'content': response,
            'timestamp': datetime.now()
        })
        
        return {
            'session_id': session_id,
            'response': response,
            'timestamp': datetime.now().isoformat()
        }
    
    def get_session_history(self, session_id: str) -> List[Dict[str, Any]]:
        """è·å–ä¼šè¯å†å²"""
        if session_id not in self.sessions:
            raise ValueError(f"ä¼šè¯ä¸å­˜åœ¨: {session_id}")
        return self.sessions[session_id]['messages']
    
    def get_session_info(self, session_id: str) -> Dict[str, Any]:
        """è·å–ä¼šè¯ä¿¡æ¯"""
        if session_id not in self.sessions:
            raise ValueError(f"ä¼šè¯ä¸å­˜åœ¨: {session_id}")
        session = self.sessions[session_id]
        return {
            'session_id': session_id,
            'user_id': session['user_id'],
            'role': session['role'].value,
            'created_at': session['created_at'].isoformat(),
            'message_count': len(session['messages'])
        }
    
    def cleanup_old_sessions(self, max_age_hours: int = 24) -> int:
        """æ¸…ç†æ—§ä¼šè¯"""
        from datetime import timedelta
        cutoff_time = datetime.now() - timedelta(hours=max_age_hours)
        old_sessions = [sid for sid, session in self.sessions.items() 
                       if session['created_at'] < cutoff_time]
        for sid in old_sessions:
            del self.sessions[sid]
        return len(old_sessions)
    
    async def generate_response(self, messages: List[Dict[str, str]], context: Dict[str, Any] = None) -> str:
        """ç”ŸæˆAIå›å¤ - åŸºäºRAG+LLM"""
        try:
            user_message = messages[-1]["content"]
            
            # 1. ä½¿ç”¨RAGæ£€ç´¢ç›¸å…³çŸ¥è¯†
            knowledge_results = []
            if self.vector_rag_service:
                try:
                    knowledge_results = await self.vector_rag_service.search_knowledge_hybrid(
                        query=user_message,
                        max_results=10
                    )
                except Exception as e:
                    logger.error(f"RAGæ£€ç´¢å¤±è´¥: {e}")
            
            # 2. ä¼˜å…ˆä½¿ç”¨LLM+RAGè¿›è¡ŒåŠ¨æ€åˆ†æ
            if knowledge_results:
                return await self._generate_dynamic_bank_comparison(knowledge_results, user_message)
            
            # 4. é»˜è®¤å›å¤
            return self._generate_default_response(user_message)
            
        except Exception as e:
            logger.error(f"ç”Ÿæˆå›å¤å¤±è´¥: {e}")
            return "æŠ±æ­‰ï¼Œæˆ‘æš‚æ—¶æ— æ³•å¤„ç†æ‚¨çš„è¯·æ±‚ï¼Œè¯·ç¨åå†è¯•ã€‚"
    
    async def _generate_dynamic_bank_comparison(self, knowledge_results: List[Dict[str, Any]], user_message: str) -> str:
        """åŸºäºRAG+LLMåŠ¨æ€ç”Ÿæˆé“¶è¡Œå¯¹æ¯”"""
        logger.info(f"å¼€å§‹ç”ŸæˆåŠ¨æ€é“¶è¡Œå¯¹æ¯”ï¼ŒçŸ¥è¯†åº“ç»“æœæ•°é‡: {len(knowledge_results)}")
        
        # 1. ä»çŸ¥è¯†åº“æå–é“¶è¡Œä¿¡æ¯
        bank_info = self._extract_bank_info_from_knowledge(knowledge_results)
        logger.info(f"æå–çš„é“¶è¡Œä¿¡æ¯æ•°é‡: {len(bank_info)}")
        
        # 2. æ„å»ºLLMæç¤ºè¯
        prompt = self._build_comparison_prompt(user_message, bank_info)
        logger.info(f"æ„å»ºçš„æç¤ºè¯é•¿åº¦: {len(prompt)}")
        
        # 3. è°ƒç”¨LLMç”Ÿæˆå›å¤
        try:
            if self.llm_service:
                logger.info("å¼€å§‹è°ƒç”¨LLMæœåŠ¡...")
                response = await self.llm_service.generate_response([{"role": "user", "content": prompt}])
                logger.info(f"LLMå“åº”: {response}")
                if response.get("success", False):
                    result = response.get("response", "æŠ±æ­‰ï¼Œæ— æ³•ç”Ÿæˆå›å¤ã€‚")
                    logger.info(f"LLMç”ŸæˆæˆåŠŸï¼Œå›å¤é•¿åº¦: {len(result)}")
                    return result
                else:
                    logger.error(f"LLMç”Ÿæˆå¤±è´¥: {response.get('error', 'æœªçŸ¥é”™è¯¯')}")
                    # å¦‚æœLLMå¤±è´¥ï¼Œä½¿ç”¨æ™ºèƒ½RAGå›å¤
                    return self._generate_smart_rag_response(bank_info, user_message)
            else:
                logger.warning("LLMæœåŠ¡æœªåˆå§‹åŒ–ï¼Œä½¿ç”¨æ™ºèƒ½RAGæ–¹æ¡ˆ")
                return self._generate_smart_rag_response(bank_info, user_message)
        except Exception as e:
            logger.error(f"LLMç”Ÿæˆå¤±è´¥: {e}")
            return self._generate_smart_rag_response(bank_info, user_message)
    
    def _extract_bank_info_from_knowledge(self, knowledge_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """ä»çŸ¥è¯†åº“ç»“æœä¸­æå–é“¶è¡Œä¿¡æ¯"""
        bank_info = []
        
        for result in knowledge_results:
            title = result.get('title', '')
            content = result.get('content', '')
            
            # è¿‡æ»¤æ‰ä¹±ç å†…å®¹
            if any(char in content for char in ['nnnnnnnn', 'â– â– â– â– ', '(cid:127)']):
                continue
            
            # æ£€æŸ¥æ˜¯å¦åŒ…å«é“¶è¡Œä¿¡æ¯
            bank_keywords = ['é“¶è¡Œ', 'è´·æ¬¾', 'åˆ©ç‡', 'é¢åº¦', 'å®¡æ‰¹', 'æ¡ä»¶', 'äº§å“']
            if any(keyword in title or keyword in content for keyword in bank_keywords):
                bank_info.append({
                    'title': title,
                    'content': content[:1000],  # é™åˆ¶é•¿åº¦
                    'source': result.get('source', ''),
                    'score': result.get('score', 0)
                })
        
        return bank_info
    
    def _build_comparison_prompt(self, user_message: str, bank_info: List[Dict[str, Any]]) -> str:
        """æ„å»ºé“¶è¡Œå¯¹æ¯”çš„LLMæç¤ºè¯"""
        prompt = f"""ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„è´·æ¬¾é¡¾é—®ã€‚ç”¨æˆ·è¯¢é—®ï¼š"{user_message}"

åŸºäºä»¥ä¸‹é“¶è¡Œä¿¡æ¯ï¼Œä¸ºç”¨æˆ·æä¾›è¯¦ç»†çš„é“¶è¡Œå¯¹æ¯”åˆ†æï¼š

é“¶è¡Œä¿¡æ¯ï¼š
{self._format_bank_info_for_llm(bank_info)}

è¯·æŒ‰ç…§ä»¥ä¸‹æ ¼å¼å›å¤ï¼š
1. åˆ†æå„é“¶è¡Œçš„äº§å“ç‰¹ç‚¹å’Œä¼˜åŠ¿
2. æ¨èæœ€é€‚åˆçš„é“¶è¡Œï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
3. æä¾›å…·ä½“çš„ç”³è¯·å»ºè®®å’Œæ³¨æ„äº‹é¡¹
4. åˆ—å‡ºå¿…å¤‡ææ–™æ¸…å•

è¦æ±‚ï¼š
- åŸºäºå®é™…ä¿¡æ¯è¿›è¡Œåˆ†æï¼Œä¸è¦ç¼–é€ æ•°æ®
- æ ¼å¼æ¸…æ™°ï¼Œä¾¿äºé˜…è¯»
- æä¾›å®ç”¨çš„å»ºè®®
- å¦‚æœä¿¡æ¯ä¸è¶³ï¼Œè¯·è¯´æ˜å¹¶å»ºè®®ç”¨æˆ·å’¨è¯¢å…·ä½“é“¶è¡Œ
- å¦‚æœç”¨æˆ·æ˜ç¡®è¦æ±‚å¯¹æ¯”Nå®¶é“¶è¡Œï¼Œè¯·å°½é‡æä¾›Nå®¶é“¶è¡Œçš„å¯¹æ¯”ï¼Œå¦‚æœçŸ¥è¯†åº“ä¸­ä¸è¶³ï¼Œè¯·è¯´æ˜ã€‚
"""
        return prompt

    def _generate_fallback_comparison(self, bank_info: List[Dict[str, Any]], user_message: str) -> str:
        """å½“LLMä¸å¯ç”¨æ—¶çš„å¤‡ç”¨å›å¤"""
        if not bank_info:
            return """ğŸ’° **é“¶è¡Œå¯¹æ¯”åˆ†æ**

æŠ±æ­‰ï¼Œç›®å‰æ²¡æœ‰æ‰¾åˆ°ç›¸å…³çš„é“¶è¡Œä¿¡æ¯ã€‚å»ºè®®æ‚¨ï¼š

1. ç›´æ¥å’¨è¯¢å„å¤§é“¶è¡Œå®¢æœ
2. è®¿é—®é“¶è¡Œå®˜ç½‘äº†è§£äº§å“è¯¦æƒ…
3. åˆ°é“¶è¡Œç½‘ç‚¹è¿›è¡Œè¯¦ç»†å’¨è¯¢

ä¸»è¦é“¶è¡ŒåŒ…æ‹¬ï¼š
- å›½æœ‰å¤§è¡Œï¼šå·¥å•†é“¶è¡Œã€å»ºè®¾é“¶è¡Œã€ä¸­å›½é“¶è¡Œã€å†œä¸šé“¶è¡Œ
- è‚¡ä»½åˆ¶é“¶è¡Œï¼šæ‹›å•†é“¶è¡Œã€æµ¦å‘é“¶è¡Œã€æ°‘ç”Ÿé“¶è¡Œã€å…´ä¸šé“¶è¡Œ
- åŸå•†è¡Œï¼šåŒ—äº¬é“¶è¡Œã€ä¸Šæµ·é“¶è¡Œã€æ±Ÿè‹é“¶è¡Œç­‰

å¦‚éœ€æ›´è¯¦ç»†çš„ä¿¡æ¯ï¼Œè¯·å‘Šè¯‰æˆ‘æ‚¨çš„å…·ä½“éœ€æ±‚ã€‚"""
        
        # åŸºäºçŸ¥è¯†åº“ä¿¡æ¯åŠ¨æ€ç”Ÿæˆå¯¹æ¯”åˆ†æ
        return f"""ğŸ’° **é“¶è¡Œå¯¹æ¯”åˆ†æ**

åŸºäºçŸ¥è¯†åº“ä¿¡æ¯ï¼Œä¸ºæ‚¨åˆ†æä»¥ä¸‹é“¶è¡Œï¼š

{self._format_bank_info_for_llm(bank_info)}

ğŸ’¡ **æ™ºèƒ½åˆ†æå»ºè®®**

æ ¹æ®çŸ¥è¯†åº“ä¸­çš„ä¿¡æ¯ï¼Œæˆ‘ä¸ºæ‚¨æä¾›ä»¥ä¸‹åˆ†æï¼š

**ğŸ“Š åŸºäºå®é™…æ•°æ®çš„åˆ†æï¼š**
- ä»¥ä¸Šä¿¡æ¯å‡æ¥è‡ªçŸ¥è¯†åº“ä¸­çš„çœŸå®é“¶è¡Œæ•°æ®
- å»ºè®®æ‚¨æ ¹æ®è‡ªèº«æƒ…å†µé€‰æ‹©æœ€é€‚åˆçš„é“¶è¡Œ
- å¦‚éœ€æ›´è¯¦ç»†çš„ä¿¡æ¯ï¼Œè¯·å’¨è¯¢å…·ä½“é“¶è¡Œ

**ğŸ¯ é€‰æ‹©å»ºè®®ï¼š**
è¯·æ ¹æ®æ‚¨çš„å…·ä½“è´·æ¬¾é‡‘é¢ã€æ”¶å…¥æ°´å¹³ã€æ—¶é—´è¦æ±‚ç­‰å› ç´ ï¼Œç»“åˆä¸Šè¿°é“¶è¡Œä¿¡æ¯ï¼Œé€‰æ‹©æœ€é€‚åˆçš„é“¶è¡Œã€‚å¦‚éœ€æ›´è¯¦ç»†çš„åˆ†æï¼Œè¯·å‘Šè¯‰æˆ‘æ‚¨çš„å…·ä½“éœ€æ±‚ã€‚"""
    
    def _format_bank_info_for_llm(self, bank_info: List[Dict[str, Any]]) -> str:
        """å°†é“¶è¡Œä¿¡æ¯æ ¼å¼åŒ–ä¸ºLLMè¾“å…¥"""
        if not bank_info:
            return "æš‚æ— ç›¸å…³é“¶è¡Œä¿¡æ¯"
        
        formatted_info = []
        for i, info in enumerate(bank_info[:8], 1):  # é™åˆ¶å‰8ä¸ªç»“æœ
            title = info.get('title', '')
            content = info.get('content', '')
            formatted_info.append(f"{i}. {title}\n{content}\n")
        
        return '\n'.join(formatted_info)
    
    def _generate_knowledge_based_response(self, user_message: str, knowledge_results: List[Dict[str, Any]]) -> str:
        """åŸºäºçŸ¥è¯†åº“ç”Ÿæˆå›å¤"""
        if not knowledge_results:
            return self._generate_default_response(user_message)
        
        # åˆ†æç”¨æˆ·é—®é¢˜ç±»å‹
        message_lower = user_message.lower()
        
        if any(word in message_lower for word in ["å¯¹æ¯”", "æ¯”è¾ƒ", "å“ªä¸ª", "å“ªä¸ªå¥½", "åŒºåˆ«", "æœ‰åˆ©", "æœ€å¥½", "æ¨è"]):
            return self._format_bank_comparison(knowledge_results)
        elif any(word in message_lower for word in ["ææ–™", "ç”³è¯·", "éœ€è¦"]):
            return self._format_application_materials(knowledge_results)
        elif any(word in message_lower for word in ["æµç¨‹", "æ­¥éª¤", "æ€ä¹ˆ"]):
            return self._format_application_process(knowledge_results)
        else:
            return self._format_general_info(knowledge_results)
    
    def _format_bank_comparison(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """æ ¼å¼åŒ–é“¶è¡Œå¯¹æ¯”ä¿¡æ¯"""
        formatted_lines = []
        formatted_lines.append("ğŸ¦ **é“¶è¡Œäº§å“å¯¹æ¯”åˆ†æ**")
        formatted_lines.append("=" * 40)
        formatted_lines.append("")
        
        for i, result in enumerate(knowledge_results[:5], 1):
            title = result.get('title', '')
            content = result.get('content', '')
            
            # è¿‡æ»¤ä¹±ç å†…å®¹
            if any(char in content for char in ['nnnnnnnn', 'â– â– â– â– ', '(cid:127)']):
                continue
            
            formatted_lines.append(f"**{i}. {title}**")
            formatted_lines.append("-" * 30)
            
            # æˆªå–å‰200å­—ç¬¦
            preview = content[:200] + "..." if len(content) > 200 else content
            formatted_lines.append(preview)
            formatted_lines.append("")
        
        return '\n'.join(formatted_lines)
    
    def _format_application_materials(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """æ ¼å¼åŒ–ç”³è¯·ææ–™ä¿¡æ¯"""
        formatted_lines = []
        formatted_lines.append("ğŸ“‹ **è´·æ¬¾ç”³è¯·ææ–™æ¸…å•**")
        formatted_lines.append("=" * 40)
        formatted_lines.append("")
        
        for result in knowledge_results[:3]:
            title = result.get('title', '')
            content = result.get('content', '')
            
            if 'ææ–™æ¸…å•' in title or 'ç”³è¯·ææ–™' in title or ('é“¶è¡Œ' in title and 'ææ–™' in content):
                formatted_lines.append(f"**{title}**")
                formatted_lines.append("-" * 30)
                formatted_lines.append(content[:300])
                formatted_lines.append("")
        
        return '\n'.join(formatted_lines)
    
    def _format_application_process(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """æ ¼å¼åŒ–ç”³è¯·æµç¨‹ä¿¡æ¯"""
        formatted_lines = []
        formatted_lines.append("ğŸ“ **è´·æ¬¾ç”³è¯·æµç¨‹**")
        formatted_lines.append("=" * 30)
        formatted_lines.append("")
        
        for result in knowledge_results[:3]:
            title = result.get('title', '')
            content = result.get('content', '')
            
            if 'æµç¨‹' in title or 'æ­¥éª¤' in title:
                formatted_lines.append(f"**{title}**")
                formatted_lines.append("-" * 25)
                formatted_lines.append(content[:300])
                formatted_lines.append("")
        
        return '\n'.join(formatted_lines)
    
    def _format_general_info(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """æ ¼å¼åŒ–ä¸€èˆ¬ä¿¡æ¯"""
        formatted_lines = []
        formatted_lines.append("ğŸ’¡ **ç›¸å…³ä¿¡æ¯**")
        formatted_lines.append("=" * 25)
        formatted_lines.append("")
        
        for result in knowledge_results[:3]:
            title = result.get('title', '')
            content = result.get('content', '')
            
            formatted_lines.append(f"**{title}**")
            formatted_lines.append("-" * 20)
            formatted_lines.append(content[:200])
            formatted_lines.append("")
        
        return '\n'.join(formatted_lines)
    
    def _generate_default_response(self, user_message: str) -> str:
        """ç”Ÿæˆé»˜è®¤å›å¤"""
        return """æˆ‘æ˜¯AIæ™ºèƒ½å®¢æœï¼Œä¸“é—¨ä¸ºæ‚¨æä¾›è´·æ¬¾ç›¸å…³çš„å’¨è¯¢æœåŠ¡ã€‚

æˆ‘å¯ä»¥å¸®åŠ©æ‚¨ï¼š
â€¢ äº†è§£å„ç±»é“¶è¡Œçš„è´·æ¬¾äº§å“
â€¢ æ¯”è¾ƒä¸åŒé“¶è¡Œçš„åˆ©ç‡å’Œæ¡ä»¶
â€¢ è§£ç­”è´·æ¬¾ç”³è¯·ç›¸å…³é—®é¢˜
â€¢ æä¾›ä¸“ä¸šçš„è´·æ¬¾å»ºè®®

è¯·å‘Šè¯‰æˆ‘æ‚¨å…·ä½“æƒ³äº†è§£ä»€ä¹ˆï¼Œæˆ‘ä¼šå°½åŠ›ä¸ºæ‚¨æä¾›è¯¦ç»†çš„ä¿¡æ¯ã€‚"""

class AIChatbotService:
    """AIèŠå¤©æœºå™¨äººæœåŠ¡ - åŸºäºRAG+LLMåŠ¨æ€ç”Ÿæˆé“¶è¡Œå¯¹æ¯”"""
    
    def __init__(self, vector_rag_service=None, llm_service=None):
        self.vector_rag_service = vector_rag_service
        self.llm_service = llm_service
    
    async def generate_response(self, messages: List[Dict[str, str]], context: Dict[str, Any] = None) -> str:
        """ç”ŸæˆAIå›å¤ - åŸºäºRAG+LLM"""
        try:
            user_message = messages[-1]["content"]
            
            # 1. ä½¿ç”¨RAGæ£€ç´¢ç›¸å…³çŸ¥è¯†
            knowledge_results = []
            if self.vector_rag_service:
                try:
                    knowledge_results = await self.vector_rag_service.search_knowledge_hybrid(
                        query=user_message,
                        max_results=10
                    )
                except Exception as e:
                    logger.error(f"RAGæ£€ç´¢å¤±è´¥: {e}")
            
            # 2. æ£€æŸ¥æ˜¯å¦æ˜¯é“¶è¡Œå¯¹æ¯”é—®é¢˜
            if any(word in user_message for word in ["å¯¹æ¯”", "æ¯”è¾ƒ", "æ¨è", "å“ªå®¶", "å“ªä¸ª", "æœ€å¥½", "é€‰æ‹©"]):
                return self._generate_fallback_comparison(knowledge_results, user_message)
            
            # 3. åŸºäºçŸ¥è¯†åº“ç”Ÿæˆå›å¤
            if knowledge_results:
                return self._generate_knowledge_based_response(user_message, knowledge_results)
            
            # 4. é»˜è®¤å›å¤
            return self._generate_default_response(user_message)
            
        except Exception as e:
            logger.error(f"ç”Ÿæˆå›å¤å¤±è´¥: {e}")
            return "æŠ±æ­‰ï¼Œæˆ‘æš‚æ—¶æ— æ³•å¤„ç†æ‚¨çš„è¯·æ±‚ï¼Œè¯·ç¨åå†è¯•ã€‚"
    
    def _generate_fallback_comparison(self, bank_info: List[Dict[str, Any]], user_message: str) -> str:
        """å½“LLMä¸å¯ç”¨æ—¶çš„å¤‡ç”¨å›å¤"""
        if not bank_info:
            return """ğŸ’° **é“¶è¡Œå¯¹æ¯”åˆ†æ**

æŠ±æ­‰ï¼Œç›®å‰æ²¡æœ‰æ‰¾åˆ°ç›¸å…³çš„é“¶è¡Œä¿¡æ¯ã€‚å»ºè®®æ‚¨ï¼š

1. ç›´æ¥å’¨è¯¢å„å¤§é“¶è¡Œå®¢æœ
2. è®¿é—®é“¶è¡Œå®˜ç½‘äº†è§£äº§å“è¯¦æƒ…
3. åˆ°é“¶è¡Œç½‘ç‚¹è¿›è¡Œè¯¦ç»†å’¨è¯¢

ä¸»è¦é“¶è¡ŒåŒ…æ‹¬ï¼š
- å›½æœ‰å¤§è¡Œï¼šå·¥å•†é“¶è¡Œã€å»ºè®¾é“¶è¡Œã€ä¸­å›½é“¶è¡Œã€å†œä¸šé“¶è¡Œ
- è‚¡ä»½åˆ¶é“¶è¡Œï¼šæ‹›å•†é“¶è¡Œã€æµ¦å‘é“¶è¡Œã€æ°‘ç”Ÿé“¶è¡Œã€å…´ä¸šé“¶è¡Œ
- åŸå•†è¡Œï¼šåŒ—äº¬é“¶è¡Œã€ä¸Šæµ·é“¶è¡Œã€æ±Ÿè‹é“¶è¡Œç­‰

å¦‚éœ€æ›´è¯¦ç»†çš„ä¿¡æ¯ï¼Œè¯·å‘Šè¯‰æˆ‘æ‚¨çš„å…·ä½“éœ€æ±‚ã€‚"""
        
        # åŸºäºçŸ¥è¯†åº“ä¿¡æ¯åŠ¨æ€ç”Ÿæˆå¯¹æ¯”åˆ†æ
        return f"""ğŸ’° **é“¶è¡Œå¯¹æ¯”åˆ†æ**

åŸºäºçŸ¥è¯†åº“ä¿¡æ¯ï¼Œä¸ºæ‚¨åˆ†æä»¥ä¸‹é“¶è¡Œï¼š

{self._format_bank_info_for_llm(bank_info)}

ğŸ’¡ **æ™ºèƒ½åˆ†æå»ºè®®**

æ ¹æ®çŸ¥è¯†åº“ä¸­çš„ä¿¡æ¯ï¼Œæˆ‘ä¸ºæ‚¨æä¾›ä»¥ä¸‹åˆ†æï¼š

**ğŸ“Š åŸºäºå®é™…æ•°æ®çš„åˆ†æï¼š**
- ä»¥ä¸Šä¿¡æ¯å‡æ¥è‡ªçŸ¥è¯†åº“ä¸­çš„çœŸå®é“¶è¡Œæ•°æ®
- å»ºè®®æ‚¨æ ¹æ®è‡ªèº«æƒ…å†µé€‰æ‹©æœ€é€‚åˆçš„é“¶è¡Œ
- å¦‚éœ€æ›´è¯¦ç»†çš„ä¿¡æ¯ï¼Œè¯·å’¨è¯¢å…·ä½“é“¶è¡Œ

**ğŸ¯ é€‰æ‹©å»ºè®®ï¼š**
è¯·æ ¹æ®æ‚¨çš„å…·ä½“è´·æ¬¾é‡‘é¢ã€æ”¶å…¥æ°´å¹³ã€æ—¶é—´è¦æ±‚ç­‰å› ç´ ï¼Œç»“åˆä¸Šè¿°é“¶è¡Œä¿¡æ¯ï¼Œé€‰æ‹©æœ€é€‚åˆçš„é“¶è¡Œã€‚å¦‚éœ€æ›´è¯¦ç»†çš„åˆ†æï¼Œè¯·å‘Šè¯‰æˆ‘æ‚¨çš„å…·ä½“éœ€æ±‚ã€‚"""
    
    def _format_bank_info_for_llm(self, bank_info: List[Dict[str, Any]]) -> str:
        """å°†é“¶è¡Œä¿¡æ¯æ ¼å¼åŒ–ä¸ºLLMè¾“å…¥"""
        if not bank_info:
            return "æš‚æ— ç›¸å…³é“¶è¡Œä¿¡æ¯"
        
        formatted_info = []
        for i, info in enumerate(bank_info[:8], 1):  # é™åˆ¶å‰8ä¸ªç»“æœ
            title = info.get('title', '')
            content = info.get('content', '')
            formatted_info.append(f"{i}. {title}\n{content}\n")
        
        return '\n'.join(formatted_info)
    
    def _generate_knowledge_based_response(self, user_message: str, knowledge_results: List[Dict[str, Any]]) -> str:
        """åŸºäºçŸ¥è¯†åº“ç”Ÿæˆå›å¤"""
        if not knowledge_results:
            return self._generate_default_response(user_message)
        
        # åˆ†æç”¨æˆ·é—®é¢˜ç±»å‹
        message_lower = user_message.lower()
        
        if any(word in message_lower for word in ["å¯¹æ¯”", "æ¯”è¾ƒ", "å“ªä¸ª", "å“ªä¸ªå¥½", "åŒºåˆ«", "æœ‰åˆ©", "æœ€å¥½", "æ¨è"]):
            return self._format_bank_comparison(knowledge_results)
        elif any(word in message_lower for word in ["ææ–™", "ç”³è¯·", "éœ€è¦"]):
            return self._format_application_materials(knowledge_results)
        elif any(word in message_lower for word in ["æµç¨‹", "æ­¥éª¤", "æ€ä¹ˆ"]):
            return self._format_application_process(knowledge_results)
        else:
            return self._format_general_info(knowledge_results)
    
    def _format_bank_comparison(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """æ ¼å¼åŒ–é“¶è¡Œå¯¹æ¯”ä¿¡æ¯"""
        formatted_lines = []
        formatted_lines.append("ğŸ¦ **é“¶è¡Œäº§å“å¯¹æ¯”åˆ†æ**")
        formatted_lines.append("=" * 40)
        formatted_lines.append("")
        
        for i, result in enumerate(knowledge_results[:5], 1):
            title = result.get('title', '')
            content = result.get('content', '')
            
            # è¿‡æ»¤ä¹±ç å†…å®¹
            if any(char in content for char in ['nnnnnnnn', 'â– â– â– â– ', '(cid:127)']):
                continue
            
            formatted_lines.append(f"**{i}. {title}**")
            formatted_lines.append("-" * 30)
            
            # æˆªå–å‰200å­—ç¬¦
            preview = content[:200] + "..." if len(content) > 200 else content
            formatted_lines.append(preview)
            formatted_lines.append("")
        
        return '\n'.join(formatted_lines)
    
    def _format_application_materials(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """æ ¼å¼åŒ–ç”³è¯·ææ–™ä¿¡æ¯"""
        formatted_lines = []
        formatted_lines.append("ğŸ“‹ **è´·æ¬¾ç”³è¯·ææ–™æ¸…å•**")
        formatted_lines.append("=" * 40)
        formatted_lines.append("")
        
        for result in knowledge_results[:3]:
            title = result.get('title', '')
            content = result.get('content', '')
            
            if 'ææ–™æ¸…å•' in title or 'ç”³è¯·ææ–™' in title or ('é“¶è¡Œ' in title and 'ææ–™' in content):
                formatted_lines.append(f"**{title}**")
                formatted_lines.append("-" * 30)
                formatted_lines.append(content[:300])
                formatted_lines.append("")
        
        return '\n'.join(formatted_lines)
    
    def _format_application_process(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """æ ¼å¼åŒ–ç”³è¯·æµç¨‹ä¿¡æ¯"""
        formatted_lines = []
        formatted_lines.append("ğŸ“ **è´·æ¬¾ç”³è¯·æµç¨‹**")
        formatted_lines.append("=" * 30)
        formatted_lines.append("")
        
        for result in knowledge_results[:3]:
            title = result.get('title', '')
            content = result.get('content', '')
            
            if 'æµç¨‹' in title or 'æ­¥éª¤' in title:
                formatted_lines.append(f"**{title}**")
                formatted_lines.append("-" * 25)
                formatted_lines.append(content[:300])
                formatted_lines.append("")
        
        return '\n'.join(formatted_lines)
    
    def _format_general_info(self, knowledge_results: List[Dict[str, Any]]) -> str:
        """æ ¼å¼åŒ–ä¸€èˆ¬ä¿¡æ¯"""
        formatted_lines = []
        formatted_lines.append("ğŸ’¡ **ç›¸å…³ä¿¡æ¯**")
        formatted_lines.append("=" * 25)
        formatted_lines.append("")
        
        for result in knowledge_results[:3]:
            title = result.get('title', '')
            content = result.get('content', '')
            
            formatted_lines.append(f"**{title}**")
            formatted_lines.append("-" * 20)
            formatted_lines.append(content[:200])
            formatted_lines.append("")
        
        return '\n'.join(formatted_lines)
    
    def _generate_default_response(self, user_message: str) -> str:
        """ç”Ÿæˆé»˜è®¤å›å¤"""
        return """æˆ‘æ˜¯AIæ™ºèƒ½å®¢æœï¼Œä¸“é—¨ä¸ºæ‚¨æä¾›è´·æ¬¾ç›¸å…³çš„å’¨è¯¢æœåŠ¡ã€‚

æˆ‘å¯ä»¥å¸®åŠ©æ‚¨ï¼š
â€¢ äº†è§£å„ç±»é“¶è¡Œçš„è´·æ¬¾äº§å“
â€¢ æ¯”è¾ƒä¸åŒé“¶è¡Œçš„åˆ©ç‡å’Œæ¡ä»¶
â€¢ è§£ç­”è´·æ¬¾ç”³è¯·ç›¸å…³é—®é¢˜
â€¢ æä¾›ä¸“ä¸šçš„è´·æ¬¾å»ºè®®

è¯·å‘Šè¯‰æˆ‘æ‚¨å…·ä½“æƒ³äº†è§£ä»€ä¹ˆï¼Œæˆ‘ä¼šå°½åŠ›ä¸ºæ‚¨æä¾›è¯¦ç»†çš„ä¿¡æ¯ã€‚""" 
         d e f   _ g e n e r a t e _ s m a r t _ r a g _ r e s p o n s e ( s e l f ,   b a n k _ i n f o :   L i s t [ D i c t [ s t r ,   A n y ] ] ,   u s e r _ m e s s a g e :   s t r )   - >   s t r :  
                 \  
 \ \ ubzfı€R A G ŞVY 
 -  
 úWNÀh"}0R„våwÆ‹ÛLˆzfı€Rg\ \ \  
 